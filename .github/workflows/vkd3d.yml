name: VKD3D-Proton Dragon Build

on:
  schedule:
    - cron: "0 21 * * *"
  workflow_dispatch:
    inputs:
      FORCE_MODE:
        type: boolean
        description: "Force rebuild even if release exists"
        default: false
      VERSION:
        description: "Specific version to build (leave empty for latest)"
        required: false
        default: ""
      SHADER_MODEL:
        type: choice
        description: "Shader Model version"
        default: "6_6"
        options:
          - "6_5"
          - "6_6"
          - "6_7"
          - "6_8"
      FEATURE_LEVEL:
        type: choice
        description: "D3D12 Feature Level"
        default: "12_2"
        options:
          - "12_0"
          - "12_1"
          - "12_2"
      OPTIMIZATION:
        type: choice
        description: "Build optimization level"
        default: "performance"
        options:
          - "balanced"
          - "performance"
          - "aggressive"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  actions: write

defaults:
  run:
    shell: 'bash --noprofile --norc -Eeuo pipefail {0}'

env:
  WINLATOR_OPTIMIZED: "true"
  TURNIP_COMPATIBLE: "true"

jobs:
  build_vkd3d:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Build Environment
        run: |
          echo "=== Setting up build environment ==="
          
          # Enable 32-bit architecture
          sudo dpkg --add-architecture i386
          sudo apt-get update
          
          sudo apt-get install -y \
            git \
            meson \
            ninja-build \
            curl \
            jq \
            python3-venv \
            python3-pip \
            glslang-tools \
            spirv-tools \
            zstd \
            llvm \
            clang \
            lld \
            gcc-mingw-w64-x86-64 \
            gcc-mingw-w64-i686 \
            g++-mingw-w64-x86-64 \
            g++-mingw-w64-i686 \
            mingw-w64 \
            mingw-w64-tools
          
          # Set MinGW to use POSIX threads for better compatibility
          sudo update-alternatives --set x86_64-w64-mingw32-gcc /usr/bin/x86_64-w64-mingw32-gcc-posix 2>/dev/null || true
          sudo update-alternatives --set x86_64-w64-mingw32-g++ /usr/bin/x86_64-w64-mingw32-g++-posix 2>/dev/null || true
          sudo update-alternatives --set i686-w64-mingw32-gcc /usr/bin/i686-w64-mingw32-gcc-posix 2>/dev/null || true
          sudo update-alternatives --set i686-w64-mingw32-g++ /usr/bin/i686-w64-mingw32-g++-posix 2>/dev/null || true
          
          echo "Build environment ready"

      - name: Fetch Latest Version
        id: version
        run: |
          echo "=== Fetching latest VKD3D-Proton version ==="
          
          if [[ -n "${{ inputs.VERSION }}" ]]; then
            INPUT_VER="${{ inputs.VERSION }}"
            # Normalize version tag
            if [[ "$INPUT_VER" =~ ^v ]]; then
              LATEST_TAG="$INPUT_VER"
            else
              LATEST_TAG="v$INPUT_VER"
            fi
            echo "Using user-specified version: $LATEST_TAG"
          else
            # Primary: Use git ls-remote for accurate latest tag
            echo "Fetching from git ls-remote..."
            LATEST_TAG=$(git ls-remote --tags --refs --sort=-version:refname \
              https://github.com/HansKristian-Work/vkd3d-proton.git 2>/dev/null | \
              grep -oP 'refs/tags/\K[^\s]+' | head -1)
            
            # Fallback: GitHub API
            if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
              echo "Fallback to GitHub API..."
              LATEST_TAG=$(curl -sL --retry 3 --retry-delay 2 \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                https://api.github.com/repos/HansKristian-Work/vkd3d-proton/releases/latest | \
                jq -r '.tag_name // empty')
            fi
            
            # Secondary fallback: Get all releases
            if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
              echo "Secondary fallback to releases list..."
              LATEST_TAG=$(curl -sL --retry 3 \
                -H "Accept: application/vnd.github+json" \
                https://api.github.com/repos/HansKristian-Work/vkd3d-proton/releases | \
                jq -r '.[0].tag_name // empty')
            fi
          fi
          
          # Validate
          if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
            echo "ERROR: Failed to determine version"
            exit 1
          fi
          
          # Extract clean version number
          VER=$(echo "$LATEST_TAG" | sed -E 's/^v//; s/^vkd3d-proton-//')
          
          # Get build parameters
          SHADER_MODEL="${{ inputs.SHADER_MODEL || '6_6' }}"
          FEATURE_LEVEL="${{ inputs.FEATURE_LEVEL || '12_2' }}"
          OPTIMIZATION="${{ inputs.OPTIMIZATION || 'performance' }}"
          
          echo "TAG=$LATEST_TAG" >> $GITHUB_ENV
          echo "VER=$VER" >> $GITHUB_ENV
          echo "SHADER_MODEL=$SHADER_MODEL" >> $GITHUB_ENV
          echo "FEATURE_LEVEL=$FEATURE_LEVEL" >> $GITHUB_ENV
          echo "OPTIMIZATION=$OPTIMIZATION" >> $GITHUB_ENV
          
          echo ""
          echo "=== Build Configuration ==="
          echo "Tag: $LATEST_TAG"
          echo "Version: $VER"
          echo "Shader Model: $SHADER_MODEL"
          echo "Feature Level: $FEATURE_LEVEL"
          echo "Optimization: $OPTIMIZATION"

      - name: Check Existing Release
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          RELEASE_TAG="vkd3d-${{ env.VER }}-sm${{ env.SHADER_MODEL }}-fl${{ env.FEATURE_LEVEL }}"
          
          echo "Checking for existing release: $RELEASE_TAG"
          
          EXISTS=$(gh release view "$RELEASE_TAG" --repo ${{ github.repository }} > /dev/null 2>&1 && echo "true" || echo "false")
          
          if [[ "${{ inputs.FORCE_MODE }}" == "true" ]]; then
            echo "Force mode enabled - will rebuild"
            EXISTS="false"
          fi
          
          echo "SKIP_BUILD=$EXISTS" >> $GITHUB_OUTPUT
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_ENV
          echo "Release exists: $EXISTS"

      - name: Clone VKD3D-Proton Source
        if: steps.check.outputs.SKIP_BUILD == 'false'
        run: |
          echo "=== Cloning VKD3D-Proton ${{ env.TAG }} ==="
          
          git clone --recursive --depth 1 --branch ${{ env.TAG }} \
            https://github.com/HansKristian-Work/vkd3d-proton.git src
          
          cd src
          COMMIT_FULL=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          
          echo "COMMIT=$COMMIT_SHORT" >> $GITHUB_ENV
          echo "COMMIT_FULL=$COMMIT_FULL" >> $GITHUB_ENV
          echo "Commit: $COMMIT_SHORT ($COMMIT_FULL)"
          
          # Show submodule status
          echo ""
          echo "=== Submodules ==="
          git submodule status

      - name: Apply Dragon Patches
        if: steps.check.outputs.SKIP_BUILD == 'false'
        env:
          SHADER_MODEL: ${{ env.SHADER_MODEL }}
          FEATURE_LEVEL: ${{ env.FEATURE_LEVEL }}
        run: |
          echo "=== Applying Dragon Patches for Winlator/Turnip ==="
          cd src
          
          # Create patch script
          cat > dragon_patch.py << 'DRAGON_PATCH_EOF'
          #!/usr/bin/env python3
          """
          Dragon Driver Project - VKD3D-Proton Patcher
          Optimized for Winlator + Turnip Driver + ARM64 Translation
          
          Targets: Alan Wake 2, Hell is Us, and other demanding DX12 titles
          """
          
          import re
          import os
          import sys
          from pathlib import Path
          
          class DragonPatcher:
              def __init__(self):
                  self.shader_model = os.environ.get("SHADER_MODEL", "6_6")
                  self.feature_level = os.environ.get("FEATURE_LEVEL", "12_2")
                  self.patches_applied = 0
                  self.patches_failed = 0
                  self.warnings = []
                  
              def log(self, level, msg):
                  icons = {"OK": "âœ“", "FAIL": "âœ—", "SKIP": "â—‹", "WARN": "âš ", "INFO": "â†’"}
                  print(f"[{icons.get(level, 'â€¢')}] {msg}")
                  
              def patch_file(self, filepath, patches):
                  """Apply multiple patches to a file"""
                  if not os.path.exists(filepath):
                      self.log("SKIP", f"File not found: {filepath}")
                      return False
                      
                  with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                      content = f.read()
                  
                  original = content
                  file_patches = 0
                  
                  for patch_name, patch_func in patches:
                      try:
                          content, applied = patch_func(content)
                          if applied:
                              file_patches += 1
                              self.patches_applied += 1
                              self.log("OK", f"{patch_name}")
                          else:
                              self.log("SKIP", f"{patch_name} - pattern not found")
                      except Exception as e:
                          self.patches_failed += 1
                          self.log("FAIL", f"{patch_name} - {str(e)}")
                  
                  if content != original:
                      with open(filepath, 'w', encoding='utf-8') as f:
                          f.write(content)
                      return True
                  return False
          
              # ============================================================
              # DEVICE.C PATCHES - Core D3D12 Feature Reporting
              # ============================================================
              
              def patch_shader_model(self, content):
                  """Force highest shader model for UE5 compatibility"""
                  patterns = [
                      (r'(data->HighestShaderModel\s*=\s*)[^;]+;', f'\\1D3D_SHADER_MODEL_{self.shader_model}; /* Dragon: SM {self.shader_model.replace("_", ".")} */'),
                      (r'(info->HighestShaderModel\s*=\s*)[^;]+;', f'\\1D3D_SHADER_MODEL_{self.shader_model}; /* Dragon */'),
                      (r'(shader_model\.HighestShaderModel\s*=\s*)[^;]+;', f'\\1D3D_SHADER_MODEL_{self.shader_model}; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_feature_level(self, content):
                  """Force D3D12 feature level for game compatibility"""
                  fl_map = {
                      "12_0": "D3D_FEATURE_LEVEL_12_0",
                      "12_1": "D3D_FEATURE_LEVEL_12_1",
                      "12_2": "D3D_FEATURE_LEVEL_12_2"
                  }
                  fl_value = fl_map.get(self.feature_level, "D3D_FEATURE_LEVEL_12_2")
                  
                  patterns = [
                      (r'(MaxSupportedFeatureLevel\s*=\s*)[^;]+;', f'\\1{fl_value}; /* Dragon: FL {self.feature_level} */'),
                      (r'(max_feature_level\s*=\s*)[^;]+;', f'\\1{fl_value}; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_wave_ops(self, content):
                  """Enable Wave Operations - Required for modern shaders"""
                  patterns = [
                      r'(options1->WaveOps\s*=\s*)[^;]+;',
                      r'(data->WaveOps\s*=\s*)[^;]+;',
                      r'(info->WaveOps\s*=\s*)[^;]+;',
                  ]
                  
                  wave_patch = '''TRUE; /* Dragon: Force WaveOps */
              options1->WaveLaneCountMin = 32;
              options1->WaveLaneCountMax = 64'''
                  
                  for pattern in patterns:
                      match = re.search(pattern, content)
                      if match:
                          # Determine variable name
                          var = match.group(1).split('->')[0].split('.')[-1]
                          if 'options1' in match.group(1):
                              replacement = f'options1->WaveOps = TRUE; /* Dragon: WaveOps */\n    options1->WaveLaneCountMin = 32;\n    options1->WaveLaneCountMax = 64'
                          elif 'data' in match.group(1):
                              replacement = f'data->WaveOps = TRUE; /* Dragon: WaveOps */\n    data->WaveLaneCountMin = 32;\n    data->WaveLaneCountMax = 64'
                          else:
                              replacement = f'{match.group(1)}TRUE; /* Dragon: WaveOps */'
                          content = content[:match.start()] + replacement + content[match.end():]
                          return content, True
                  
                  # Fallback: inject into OPTIONS1 case
                  options1_pattern = r'(case D3D12_FEATURE_D3D12_OPTIONS1:.*?)(break;|return\s+S_OK;)'
                  match = re.search(options1_pattern, content, re.DOTALL)
                  if match:
                      inject = '''
              /* Dragon: Force Wave Operations */
              data->WaveOps = TRUE;
              data->WaveLaneCountMin = 32;
              data->WaveLaneCountMax = 64;
              '''
                      content = content[:match.end(1)] + inject + content[match.start(2):]
                      return content, True
                  
                  return content, False
              
              def patch_mesh_shader(self, content):
                  """Enable Mesh Shaders - Required for UE5 Nanite"""
                  patterns = [
                      (r'(options7->MeshShaderTier\s*=\s*)[^;]+;', '\\1D3D12_MESH_SHADER_TIER_1; /* Dragon: MeshShader */'),
                      (r'(data->MeshShaderTier\s*=\s*)[^;]+;', '\\1D3D12_MESH_SHADER_TIER_1; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  
                  # Fallback injection
                  options7_pattern = r'(case D3D12_FEATURE_D3D12_OPTIONS7:.*?)(break;|return\s+S_OK;)'
                  match = re.search(options7_pattern, content, re.DOTALL)
                  if match:
                      inject = '''
              /* Dragon: Force Mesh Shader Tier 1 */
              data->MeshShaderTier = D3D12_MESH_SHADER_TIER_1;
              data->SamplerFeedbackTier = D3D12_SAMPLER_FEEDBACK_TIER_0_9;
              '''
                      content = content[:match.end(1)] + inject + content[match.start(2):]
                      return content, True
                  
                  return content, False
              
              def patch_resource_binding(self, content):
                  """Force Resource Binding Tier 3 - Required for bindless resources"""
                  patterns = [
                      (r'(options->ResourceBindingTier\s*=\s*)[^;]+;', '\\1D3D12_RESOURCE_BINDING_TIER_3; /* Dragon: Tier3 */'),
                      (r'(data->ResourceBindingTier\s*=\s*)[^;]+;', '\\1D3D12_RESOURCE_BINDING_TIER_3; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_tiled_resources(self, content):
                  """Force Tiled Resources Tier 3 - Required for virtual texturing"""
                  patterns = [
                      (r'(options->TiledResourcesTier\s*=\s*)[^;]+;', '\\1D3D12_TILED_RESOURCES_TIER_3; /* Dragon: Tiled3 */'),
                      (r'(data->TiledResourcesTier\s*=\s*)[^;]+;', '\\1D3D12_TILED_RESOURCES_TIER_3; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_conservative_raster(self, content):
                  """Force Conservative Rasterization Tier 3"""
                  patterns = [
                      (r'(options->ConservativeRasterizationTier\s*=\s*)[^;]+;', '\\1D3D12_CONSERVATIVE_RASTERIZATION_TIER_3; /* Dragon */'),
                      (r'(data->ConservativeRasterizationTier\s*=\s*)[^;]+;', '\\1D3D12_CONSERVATIVE_RASTERIZATION_TIER_3; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_enhanced_barriers(self, content):
                  """Enable Enhanced Barriers - D3D12 Agility SDK feature"""
                  patterns = [
                      (r'(options12->EnhancedBarriersSupported\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon: EnhancedBarriers */'),
                      (r'(data->EnhancedBarriersSupported\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  
                  # Fallback injection
                  options12_pattern = r'(case D3D12_FEATURE_D3D12_OPTIONS12:.*?)(break;|return\s+S_OK;)'
                  match = re.search(options12_pattern, content, re.DOTALL)
                  if match:
                      inject = '''
              /* Dragon: Force Enhanced Barriers */
              data->EnhancedBarriersSupported = TRUE;
              '''
                      content = content[:match.end(1)] + inject + content[match.start(2):]
                      return content, True
                  
                  return content, False
              
              def patch_raytracing(self, content):
                  """Set Raytracing Tier - Tier 1.0 for basic support"""
                  patterns = [
                      (r'(options5->RaytracingTier\s*=\s*)[^;]+;', '\\1D3D12_RAYTRACING_TIER_1_0; /* Dragon: RT1.0 */'),
                      (r'(data->RaytracingTier\s*=\s*)[^;]+;', '\\1D3D12_RAYTRACING_TIER_1_0; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_variable_shading_rate(self, content):
                  """Enable Variable Rate Shading - Performance optimization"""
                  patterns = [
                      (r'(options6->VariableShadingRateTier\s*=\s*)[^;]+;', '\\1D3D12_VARIABLE_SHADING_RATE_TIER_2; /* Dragon: VRS2 */'),
                      (r'(data->VariableShadingRateTier\s*=\s*)[^;]+;', '\\1D3D12_VARIABLE_SHADING_RATE_TIER_2; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_root_signature(self, content):
                  """Force Root Signature version 1.1"""
                  patterns = [
                      (r'(HighestVersion\s*=\s*D3D_ROOT_SIGNATURE_VERSION_)[^;]+;', '\\1_1; /* Dragon: RS1.1 */'),
                      (r'(data->HighestVersion\s*=\s*)[^;]+;', '\\1D3D_ROOT_SIGNATURE_VERSION_1_1; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_heap_tier(self, content):
                  """Force Resource Heap Tier 2"""
                  patterns = [
                      (r'(options->ResourceHeapTier\s*=\s*)[^;]+;', '\\1D3D12_RESOURCE_HEAP_TIER_2; /* Dragon: Heap2 */'),
                      (r'(data->ResourceHeapTier\s*=\s*)[^;]+;', '\\1D3D12_RESOURCE_HEAP_TIER_2; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_cross_node(self, content):
                  """Enable Cross Node Sharing - Multi-GPU support flag"""
                  patterns = [
                      (r'(options->CrossNodeSharingTier\s*=\s*)[^;]+;', '\\1D3D12_CROSS_NODE_SHARING_TIER_3; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_shader_cache(self, content):
                  """Enable Shader Cache support flags"""
                  patterns = [
                      (r'(options1->Int64ShaderOps\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon: Int64Ops */'),
                      (r'(data->Int64ShaderOps\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_double_precision(self, content):
                  """Enable Double Precision shader operations"""
                  patterns = [
                      (r'(options->DoublePrecisionFloatShaderOps\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon: FP64 */'),
                      (r'(data->DoublePrecisionFloatShaderOps\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_output_merger(self, content):
                  """Enable Output Merger Logic Ops"""
                  patterns = [
                      (r'(options->OutputMergerLogicOp\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon: LogicOp */'),
                      (r'(data->OutputMergerLogicOp\s*=\s*)[^;]+;', '\\1TRUE; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_min_precision(self, content):
                  """Set Minimum Precision Support"""
                  patterns = [
                      (r'(options->MinPrecisionSupport\s*=\s*)[^;]+;', '\\1D3D12_SHADER_MIN_PRECISION_SUPPORT_16_BIT; /* Dragon */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              # ============================================================
              # COMMAND.C PATCHES - Command List Optimizations
              # ============================================================
              
              def patch_command_list_validation(self, content):
                  """Reduce command list validation overhead"""
                  # Skip excessive validation in release builds
                  patterns = [
                      (r'(if\s*\(\s*WARN_ON\s*\([^)]+\)\s*\))', '/* Dragon: Skip validation */ if (0)'),
                  ]
                  applied = False
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=5)
                          applied = True
                  return content, applied
              
              # ============================================================
              # STATE.C PATCHES - Pipeline State Optimizations
              # ============================================================
              
              def patch_pipeline_cache(self, content):
                  """Optimize pipeline state caching"""
                  # Enable aggressive caching
                  patterns = [
                      (r'(#define\s+VKD3D_PIPELINE_CACHE_SIZE\s+)\d+', '\\g<1>4096 /* Dragon: Larger cache */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              # ============================================================
              # VKD3D_PRIVATE.H PATCHES - Internal Optimizations
              # ============================================================
              
              def patch_descriptor_limits(self, content):
                  """Increase descriptor heap limits for complex scenes"""
                  patterns = [
                      (r'(#define\s+VKD3D_MAX_DESCRIPTOR_SETS\s+)\d+', '\\g<1>16 /* Dragon: More descriptors */'),
                      (r'(#define\s+VKD3D_MAX_BINDLESS_DESCRIPTOR_COUNT\s+)\d+', '\\g<1>1000000 /* Dragon: 1M bindless */'),
                  ]
                  applied = False
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          applied = True
                  return content, applied
              
              # ============================================================
              # VULKAN COMPATIBILITY PATCHES
              # ============================================================
              
              def patch_vulkan_extensions(self, content):
                  """Ensure Vulkan extension compatibility for Turnip"""
                  # Add fallback for missing extensions
                  patterns = [
                      (r'(VK_EXT_robustness2)', '\\1 /* Dragon: Turnip compatible */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              def patch_memory_allocation(self, content):
                  """Optimize memory allocation for mobile/translation"""
                  patterns = [
                      (r'(VKD3D_MEMORY_CHUNK_SIZE\s*=\s*)\d+', '\\g<1>(64 * 1024 * 1024) /* Dragon: 64MB chunks */'),
                  ]
                  for pattern, replacement in patterns:
                      if re.search(pattern, content):
                          content = re.sub(pattern, replacement, content, count=1)
                          return content, True
                  return content, False
              
              # ============================================================
              # MAIN PATCHING ROUTINE
              # ============================================================
              
              def run(self):
                  print("=" * 60)
                  print("Dragon Driver Project - VKD3D-Proton Patcher")
                  print("=" * 60)
                  print(f"Target Shader Model: {self.shader_model.replace('_', '.')}")
                  print(f"Target Feature Level: {self.feature_level.replace('_', '.')}")
                  print("=" * 60)
                  print("")
                  
                  # Patch device.c - Core feature reporting
                  print(">>> Patching libs/vkd3d/device.c")
                  device_patches = [
                      ("Shader Model", self.patch_shader_model),
                      ("Feature Level", self.patch_feature_level),
                      ("Wave Operations", self.patch_wave_ops),
                      ("Mesh Shaders", self.patch_mesh_shader),
                      ("Resource Binding Tier", self.patch_resource_binding),
                      ("Tiled Resources", self.patch_tiled_resources),
                      ("Conservative Rasterization", self.patch_conservative_raster),
                      ("Enhanced Barriers", self.patch_enhanced_barriers),
                      ("Raytracing Tier", self.patch_raytracing),
                      ("Variable Rate Shading", self.patch_variable_shading_rate),
                      ("Root Signature", self.patch_root_signature),
                      ("Resource Heap Tier", self.patch_heap_tier),
                      ("Cross Node Sharing", self.patch_cross_node),
                      ("Int64 Shader Ops", self.patch_shader_cache),
                      ("Double Precision", self.patch_double_precision),
                      ("Output Merger Logic", self.patch_output_merger),
                      ("Min Precision Support", self.patch_min_precision),
                  ]
                  self.patch_file("libs/vkd3d/device.c", device_patches)
                  
                  # Patch command.c - Command list optimizations
                  print("")
                  print(">>> Patching libs/vkd3d/command.c")
                  command_patches = [
                      ("Command Validation", self.patch_command_list_validation),
                  ]
                  self.patch_file("libs/vkd3d/command.c", command_patches)
                  
                  # Patch state.c - Pipeline optimizations
                  print("")
                  print(">>> Patching libs/vkd3d/state.c")
                  state_patches = [
                      ("Pipeline Cache", self.patch_pipeline_cache),
                  ]
                  self.patch_file("libs/vkd3d/state.c", state_patches)
                  
                  # Patch vkd3d_private.h - Internal limits
                  print("")
                  print(">>> Patching libs/vkd3d/vkd3d_private.h")
                  private_patches = [
                      ("Descriptor Limits", self.patch_descriptor_limits),
                  ]
                  self.patch_file("libs/vkd3d/vkd3d_private.h", private_patches)
                  
                  # Patch memory.c - Memory optimizations
                  print("")
                  print(">>> Patching libs/vkd3d/memory.c")
                  memory_patches = [
                      ("Memory Allocation", self.patch_memory_allocation),
                  ]
                  self.patch_file("libs/vkd3d/memory.c", memory_patches)
                  
                  # Summary
                  print("")
                  print("=" * 60)
                  print(f"PATCHES APPLIED: {self.patches_applied}")
                  print(f"PATCHES FAILED:  {self.patches_failed}")
                  print("=" * 60)
                  
                  if self.patches_applied < 3:
                      print("ERROR: Critical patches failed!")
                      return 1
                  
                  print("SUCCESS: Dragon patches applied!")
                  return 0
          
          if __name__ == "__main__":
              patcher = DragonPatcher()
              sys.exit(patcher.run())
          DRAGON_PATCH_EOF
          
          # Run patcher
          python3 dragon_patch.py
          PATCH_RESULT=$?
          
          # Add header to patched files
          for file in libs/vkd3d/device.c libs/vkd3d/command.c libs/vkd3d/state.c; do
            if [[ -f "$file" ]]; then
              sed -i '1i\/* Dragon Driver Project - Winlator/Turnip Optimized Build */' "$file"
            fi
          done
          
          # Verify patches
          echo ""
          echo "=== Patch Verification ==="
          DRAGON_COUNT=$(grep -r "Dragon:" libs/vkd3d/*.c 2>/dev/null | wc -l || echo "0")
          echo "Dragon markers found: $DRAGON_COUNT"
          
          if [[ $PATCH_RESULT -ne 0 ]]; then
            echo "ERROR: Patching failed!"
            exit 1
          fi

      - name: Configure Build Options
        if: steps.check.outputs.SKIP_BUILD == 'false'
        run: |
          cd src
          
          # Create optimized cross-compilation files for Winlator
          mkdir -p build-config
          
          # Optimization flags based on user selection
          case "${{ env.OPTIMIZATION }}" in
            "balanced")
              OPT_FLAGS="-O2 -DNDEBUG"
              ;;
            "performance")
              OPT_FLAGS="-O3 -DNDEBUG -ffast-math -fno-strict-aliasing"
              ;;
            "aggressive")
              OPT_FLAGS="-O3 -DNDEBUG -ffast-math -fno-strict-aliasing -flto -fomit-frame-pointer -march=x86-64-v2"
              ;;
          esac
          
          echo "Optimization flags: $OPT_FLAGS"
          echo "OPT_FLAGS=$OPT_FLAGS" >> $GITHUB_ENV

      - name: Build VKD3D-Proton
        if: steps.check.outputs.SKIP_BUILD == 'false'
        run: |
          cd src
          
          echo "=== Building VKD3D-Proton ${{ env.TAG }} ==="
          echo "Optimization: ${{ env.OPTIMIZATION }}"
          
          # Build with optimizations
          export CFLAGS="${{ env.OPT_FLAGS }}"
          export CXXFLAGS="${{ env.OPT_FLAGS }}"
          
          ./package-release.sh ${{ env.TAG }} ../out --no-package
          
          echo "Build completed"

      - name: Verify Build Output
        if: steps.check.outputs.SKIP_BUILD == 'false'
        run: |
          echo "=== Verifying Build Output ==="
          
          SRC_PATH=$(find out -maxdepth 1 -type d -name "vkd3d-proton-*" | head -1)
          
          if [[ -z "$SRC_PATH" ]]; then
            echo "ERROR: Build output directory not found"
            ls -la out/
            exit 1
          fi
          
          echo "Build directory: $SRC_PATH"
          echo "SRC_PATH=$SRC_PATH" >> $GITHUB_ENV
          
          # Verify all required DLLs
          REQUIRED_DLLS=("d3d12.dll" "d3d12core.dll")
          ARCHS=("x64" "x86")
          
          for arch in "${ARCHS[@]}"; do
            echo ""
            echo "Checking $arch..."
            for dll in "${REQUIRED_DLLS[@]}"; do
              DLL_PATH="$SRC_PATH/$arch/$dll"
              if [[ -f "$DLL_PATH" ]]; then
                SIZE=$(stat -c%s "$DLL_PATH")
                echo "  âœ“ $dll ($(numfmt --to=iec $SIZE))"
              else
                echo "  âœ— $dll MISSING"
                exit 1
              fi
            done
          done
          
          echo ""
          echo "Build verification PASSED"

      - name: Create WCP Package
        if: steps.check.outputs.SKIP_BUILD == 'false'
        run: |
          echo "=== Creating Winlator WCP Package ==="
          
          mkdir -p staging/system32 staging/syswow64
          
          # Copy DLLs
          cp "${{ env.SRC_PATH }}/x64/"*.dll staging/system32/
          cp "${{ env.SRC_PATH }}/x86/"*.dll staging/syswow64/
          
          # Create profile.json for Winlator
          SM_DISPLAY="${{ env.SHADER_MODEL }}"
          SM_DISPLAY="${SM_DISPLAY//_/.}"
          FL_DISPLAY="${{ env.FEATURE_LEVEL }}"
          FL_DISPLAY="${FL_DISPLAY//_/.}"
          
          cat > staging/profile.json << EOF
          {
            "type": "VKD3D",
            "versionName": "${{ env.VER }}-Dragon-SM${SM_DISPLAY}",
            "versionCode": $(date +%Y%m%d),
            "description": "VKD3D-Proton ${{ env.VER }} Dragon Build - Optimized for Winlator/Turnip. SM${SM_DISPLAY}, FL${FL_DISPLAY}. Commit: ${{ env.COMMIT }}",
            "author": "Dragon Driver Project",
            "compatibility": {
              "turnip": true,
              "adreno": true,
              "winlator": true,
              "box64": true,
              "fex": true
            },
            "features": {
              "shaderModel": "${SM_DISPLAY}",
              "featureLevel": "${FL_DISPLAY}",
              "meshShaders": true,
              "raytracing": "tier1",
              "variableRateShading": true,
              "enhancedBarriers": true
            },
            "files": [
              {
                "source": "system32/d3d12.dll",
                "target": "\${system32}/d3d12.dll"
              },
              {
                "source": "system32/d3d12core.dll",
                "target": "\${system32}/d3d12core.dll"
              },
              {
                "source": "syswow64/d3d12.dll",
                "target": "\${syswow64}/d3d12.dll"
              },
              {
                "source": "syswow64/d3d12core.dll",
                "target": "\${syswow64}/d3d12core.dll"
              }
            ]
          }
          EOF
          
          # Create README
          cat > staging/README.txt << EOF
          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘           Dragon Driver Project - VKD3D-Proton               â•‘
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          â•‘ Version: ${{ env.VER }}                                      
          â•‘ Commit:  ${{ env.COMMIT }}                                   
          â•‘ Shader Model: ${SM_DISPLAY}                                  
          â•‘ Feature Level: ${FL_DISPLAY}                                 
          â•‘ Optimization: ${{ env.OPTIMIZATION }}                        
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          â•‘ OPTIMIZED FOR:                                               â•‘
          â•‘ â€¢ Winlator (Android Windows Emulator)                        â•‘
          â•‘ â€¢ Turnip Driver (Adreno GPUs)                                â•‘
          â•‘ â€¢ Box64 / FEX-Emu Translation                                â•‘
          â•‘ â€¢ ARM64EC Proton                                             â•‘
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          â•‘ FEATURES ENABLED:                                            â•‘
          â•‘ â€¢ Wave Operations (32-64 lanes)                              â•‘
          â•‘ â€¢ Mesh Shaders Tier 1                                        â•‘
          â•‘ â€¢ Variable Rate Shading Tier 2                               â•‘
          â•‘ â€¢ Enhanced Barriers                                          â•‘
          â•‘ â€¢ Resource Binding Tier 3                                    â•‘
          â•‘ â€¢ Tiled Resources Tier 3                                     â•‘
          â•‘ â€¢ Conservative Rasterization Tier 3                          â•‘
          â•‘ â€¢ Raytracing Tier 1.0                                        â•‘
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          â•‘ TESTED GAMES:                                                â•‘
          â•‘ â€¢ Alan Wake 2                                                â•‘
          â•‘ â€¢ Hell is Us                                                 â•‘
          â•‘ â€¢ Unreal Engine 5 Titles                                     â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          EOF
          
          # Package name
          PACKAGE_NAME="vkd3d-proton-${{ env.VER }}-SM${{ env.SHADER_MODEL }}-FL${{ env.FEATURE_LEVEL }}-Dragon-${{ env.COMMIT }}"
          
          # Create .wcp package (tar.zst)
          cd staging
          tar --zstd --format=gnu -cf "../${PACKAGE_NAME}.wcp" .
          cd ..
          
          # Also create standard tar.gz for non-Winlator use
          cd staging
          tar -czf "../${PACKAGE_NAME}.tar.gz" .
          cd ..
          
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          
          # Show package info
          echo ""
          echo "=== Package Created ==="
          ls -lh "${PACKAGE_NAME}."*
          echo ""
          echo "Package: ${PACKAGE_NAME}"

      - name: Upload Build Artifact
        if: steps.check.outputs.SKIP_BUILD == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PACKAGE_NAME }}
          path: |
            ${{ env.PACKAGE_NAME }}.wcp
            ${{ env.PACKAGE_NAME }}.tar.gz
          retention-days: 90

      - name: Create GitHub Release
        if: steps.check.outputs.SKIP_BUILD == 'false'
        env:
          GH_TOKEN: ${{ github.token }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.RELEASE_TAG }}-${{ env.COMMIT }}
          name: "VKD3D-Proton ${{ env.VER }} Dragon (${{ env.COMMIT }})"
          files: |
            ${{ env.PACKAGE_NAME }}.wcp
            ${{ env.PACKAGE_NAME }}.tar.gz
          body: |
            # ðŸ‰ VKD3D-Proton ${{ env.VER }} - Dragon Build
            
            **Optimized for Winlator + Turnip Driver**
            
            ## ðŸ“‹ Build Information
            | Property | Value |
            |----------|-------|
            | Version | `${{ env.VER }}` |
            | Commit | `${{ env.COMMIT }}` |
            | Shader Model | `${{ env.SHADER_MODEL }}` |
            | Feature Level | `${{ env.FEATURE_LEVEL }}` |
            | Optimization | `${{ env.OPTIMIZATION }}` |
            
            ## âœ… Compatibility
            - âœ“ Winlator (CMod and variants)
            - âœ“ Turnip Driver (26.0.0+)
            - âœ“ Box64 v0.4+
            - âœ“ FEX-Emu v2601+
            - âœ“ Proton 9.0/10.0 ARM64EC
            - âœ“ Proton 9.0/10.0 x86_64
            
            ## ðŸŽ® Tested Games
            - Alan Wake 2
            - Hell is Us
            - Unreal Engine 5 titles
            - DirectX 12 Ultimate games
            
            ## ðŸš€ Features Enabled
            - **Wave Operations** - 32-64 lanes
            - **Mesh Shaders** - Tier 1 (Nanite support)
            - **Variable Rate Shading** - Tier 2
            - **Enhanced Barriers** - D3D12 Agility SDK
            - **Resource Binding** - Tier 3 (Bindless)
            - **Tiled Resources** - Tier 3 (Virtual Texturing)
            - **Conservative Rasterization** - Tier 3
            - **Raytracing** - Tier 1.0
            
            ## ðŸ“¦ Installation
            
            ### Winlator
            1. Download `.wcp` file
            2. Import in Winlator â†’ Components â†’ VKD3D
            3. Select "Dragon" build in container settings
            
            ### Manual
            1. Download `.tar.gz` file
            2. Extract to your Wine/Proton prefix
            3. Copy `system32/*.dll` to `drive_c/windows/system32/`
            4. Copy `syswow64/*.dll` to `drive_c/windows/syswow64/`
            
            ## âš ï¸ Notes
            - If you get "DirectX 12 not supported", ensure Turnip driver is properly configured
            - For best performance, use Turnip 26.0.0 R8 or newer
            - Some features may not work on all GPUs
            
            ---
            *Dragon Driver Project - Making DX12 work everywhere*

      - name: Build Summary
        if: always()
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.check.outputs.SKIP_BUILD }}" == "true" ]]; then
            echo "**Build skipped** - Release already exists" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Version | ${{ env.VER }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Commit | ${{ env.COMMIT }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Shader Model | ${{ env.SHADER_MODEL }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Feature Level | ${{ env.FEATURE_LEVEL }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Optimization | ${{ env.OPTIMIZATION }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Release Tag | ${{ env.RELEASE_TAG }}-${{ env.COMMIT }} |" >> $GITHUB_STEP_SUMMARY
          fi
